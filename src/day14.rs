use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead};

struct Game {
  last_pair: String,
  count_by_pair: HashMap<String, u64>,
  // each instruction has one polymer key that generates 2 polymers
  // ex. NN -> C generates NC and CN
  instructions: HashMap<String, Vec<String>>,
}

impl Game {
  fn parse(data: &Vec<String>) -> Self {
    let mut count_by_pair: HashMap<String, u64> = HashMap::new();
    let polymer_string: String = data[0].clone();
    // take all but last pair of chars and create a map of pairs
    for i in 0 .. polymer_string.len() - 2 {
      let polymer = polymer_string[i..i + 2].to_string();
      let counter= count_by_pair.entry(polymer).or_insert(0);
      *counter += 1;
    }
    // last pair is stored separately
    let last_pair: String = polymer_string[polymer_string.len() - 2..].to_string();

    let mut instructions: HashMap<String, Vec<String>> = HashMap::new();
    for i in 2..data.len() {
      let splits: Vec<&str> = data[i].split(" -> ").collect();
      let old_pair = splits[0].to_string();
      let mut new_pairs: Vec<String> = Vec::new();
      new_pairs.push(format!("{}{}", old_pair.chars().next().unwrap(), splits[1]));
      new_pairs.push(format!("{}{}", splits[1], old_pair.chars().last().unwrap(),));
      instructions.insert(old_pair, new_pairs);
    }
    return Self {
      count_by_pair, 
      instructions,
      last_pair,
    }
  }

  fn iterate(&mut self) {
    let mut new_polymers: HashMap<String, u64> = HashMap::new();
    let current_polymers = self.count_by_pair.clone();
    for (pair, count) in current_polymers {
      // add one polymer for 
      let generated = self.instructions.get(&pair).unwrap().clone();
      for pair in generated {
        let counter = new_polymers.entry(pair).or_insert(0);
        *counter += count;
      }
    }
    let generated: Vec<String> = self.instructions.get(&self.last_pair).unwrap().clone();
    // add first of pairs generated by the last pair
    let counter = new_polymers.entry(generated.first().unwrap().to_string()).or_insert(0);
    *counter += 1;
    
    self.last_pair = generated.last().unwrap().to_string();
    self.count_by_pair = new_polymers.clone();
  }

  fn count_by_letter(&self) -> HashMap<char, u64> {
    let mut counter_by_letter: HashMap<char, u64> = HashMap::new();
    let polymers = self.count_by_pair.clone();
    for (polymer, count) in polymers {
      // count only first char for each polymer
      let counter = counter_by_letter.entry(polymer.chars().next().unwrap()).or_insert(0);
      *counter += count;
    }

    // count both chars for last pair
    for c in self.last_pair.chars() {
      let counter = counter_by_letter.entry(c).or_insert(0);
      *counter += 1;
    }

    return counter_by_letter;
  }

  fn print_instructions(&self) {
    println!(r#"====== Instructions ======"#);
    println!(r#"{:?}"#, self.instructions);
  }

  fn print(&self) {
    println!(r#"====== Polymers ======"#);
    println!(r#"{:?}, last pair: {:}"#, self.count_by_pair, self.last_pair);
  }
}

fn solution_1(data: &Vec<String>) -> u64 {
  let mut game = Game::parse(data);
  for _ in 0..10 {
    game.iterate();
  }
  let counts_by_letter = game.count_by_letter();
  let mut counts: Vec<u64> = counts_by_letter.values().map(|x|x.clone()).collect();
  counts.sort();

  return counts.last().unwrap() - counts[0];
}

fn solution_2(data: &Vec<String>) -> u64 {
  let mut game = Game::parse(data);
  for _ in 0..40 {
    game.iterate();
  }
  let counts_by_letter = game.count_by_letter();
  let mut counts: Vec<u64> = counts_by_letter.values().map(|x|x.clone()).collect();
  counts.sort();

  return counts.last().unwrap() - counts[0];
}

fn main() {
  let test = false;
  let mut file_path: String = "inputs/day14".to_string();
  let mut emoji: String = "🎉".to_string();
  if test {
    file_path += ".test";
    emoji = "🧪".to_string();
  }
  file_path += ".txt";

  let file = File::open(file_path).unwrap();
  let data: Vec<String> = io::BufReader::new(file)
              .lines()
              .map(|line|line.unwrap())
              .collect();

  println!(r#"{:?} Part 1 result is {:?}"#, emoji, solution_1(&data));

  println!(r#"{:?} Part 2 test result is {:?}"#, emoji, solution_2(&data));
}
